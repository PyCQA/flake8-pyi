# flags: --extend-ignore=Y023

import abc
import builtins
import collections.abc
import enum
import typing
from abc import ABCMeta, abstractmethod
from collections.abc import (
    AsyncGenerator,
    AsyncIterable,
    AsyncIterator,
    Container,
    Generator,
    Iterable,
    Iterator,
    Mapping,
)
from enum import EnumMeta
from typing import Any, Generic, TypeVar, overload

import typing_extensions
from _typeshed import Self
from typing_extensions import final

class Bad(object):  # Y040 Do not inherit from "object" explicitly, as it is redundant in Python 3
    def __new__(cls, *args: Any, **kwargs: Any) -> Bad: ...  # Y034 "__new__" methods usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__new__", e.g. "def __new__(cls, *args: Any, **kwargs: Any) -> Self: ..."
    def __repr__(self) -> str: ...  # Y029 Defining __repr__ or __str__ in a stub is almost always redundant
    def __str__(self) -> builtins.str: ...  # Y029 Defining __repr__ or __str__ in a stub is almost always redundant
    def __eq__(self, other: Any) -> bool: ...  # Y032 Prefer "object" to "Any" for the second parameter in "__eq__" methods
    def __ne__(self, other: typing.Any) -> typing.Any: ...  # Y032 Prefer "object" to "Any" for the second parameter in "__ne__" methods
    def __enter__(self) -> Bad: ...  # Y034 "__enter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__enter__", e.g. "def __enter__(self) -> Self: ..."
    async def __aenter__(self) -> Bad: ...  # Y034 "__aenter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__aenter__", e.g. "async def __aenter__(self) -> Self: ..."
    def __iadd__(self, other: Bad) -> Bad: ...  # Y034 "__iadd__" methods in classes like "Bad" usually return "self" at runtime. Consider using "typing_extensions.Self" in "Bad.__iadd__", e.g. "def __iadd__(self, other: Bad) -> Self: ..."

class AlsoBad(int, builtins.object): ...  # Y040 Do not inherit from "object" explicitly, as it is redundant in Python 3

class Good:
    def __new__(cls: type[Self], *args: Any, **kwargs: Any) -> Self: ...
    @abstractmethod
    def __str__(self) -> str: ...
    @abc.abstractmethod
    def __repr__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, obj: object) -> int: ...
    def __enter__(self: Self) -> Self: ...
    async def __aenter__(self: Self) -> Self: ...
    def __ior__(self: Self, other: Self) -> Self: ...

class Fine:
    @overload
    def __new__(cls, foo: int) -> FineSubclass: ...
    @overload
    def __new__(cls, *args: Any, **kwargs: Any) -> Fine: ...
    @abc.abstractmethod
    def __str__(self) -> str: ...
    @abc.abstractmethod
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any, strange_extra_arg: list[str]) -> Any: ...
    def __ne__(self, *, kw_only_other: Any) -> bool: ...
    def __enter__(self) -> None: ...
    async def __aenter__(self) -> bool: ...

class FineSubclass(Fine): ...

class StrangeButAcceptable(str):
    @typing_extensions.overload
    def __new__(cls, foo: int) -> StrangeButAcceptableSubclass: ...
    @typing_extensions.overload
    def __new__(cls, *args: Any, **kwargs: Any) -> StrangeButAcceptable: ...
    def __str__(self) -> StrangeButAcceptable: ...
    def __repr__(self) -> StrangeButAcceptable: ...

class StrangeButAcceptableSubclass(StrangeButAcceptable): ...

class FineAndDandy:
    def __str__(self, weird_extra_arg) -> str: ...
    def __repr__(self, weird_extra_arg_with_default=...) -> str: ...

@final
class WillNotBeSubclassed:
    def __new__(cls, *args: Any, **kwargs: Any) -> WillNotBeSubclassed: ...
    def __enter__(self) -> WillNotBeSubclassed: ...
    async def __aenter__(self) -> WillNotBeSubclassed: ...

# we don't emit an error for these; out of scope for a linter
class InvalidButPluginDoesNotCrash:
    def __new__() -> InvalidButPluginDoesNotCrash: ...
    def __enter__() -> InvalidButPluginDoesNotCrash: ...
    async def __aenter__() -> InvalidButPluginDoesNotCrash: ...

class BadIterator1(Iterator[int]):
    def __iter__(self) -> Iterator[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator1" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator1.__iter__", e.g. "def __iter__(self) -> Self: ..."

class BadIterator2(typing.Iterator[int]):  # Y022 Use "collections.abc.Iterator[T]" instead of "typing.Iterator[T]" (PEP 585 syntax)
    def __iter__(self) -> Iterator[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator2" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator2.__iter__", e.g. "def __iter__(self) -> Self: ..."

class BadIterator3(typing.Iterator[int]):  # Y022 Use "collections.abc.Iterator[T]" instead of "typing.Iterator[T]" (PEP 585 syntax)
    def __iter__(self) -> collections.abc.Iterator[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator3" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator3.__iter__", e.g. "def __iter__(self) -> Self: ..."

class BadIterator4(Iterator[int]):
    # Note: *Iterable*, not *Iterator*, returned!
    def __iter__(self) -> Iterable[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator4" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadIterator4.__iter__", e.g. "def __iter__(self) -> Self: ..."

class IteratorReturningIterable:
    def __iter__(self) -> Iterable[str]: ...  # Y045 "__iter__" methods should return an Iterator, not an Iterable

class IteratorReturningSimpleGenerator1:
    def __iter__(self) -> Generator: ...  # Y058 Use "Iterator" as the return value for simple "__iter__" methods, e.g. "def __iter__(self) -> Iterator: ..."

class IteratorReturningSimpleGenerator2:
    def __iter__(self) -> collections.abc.Generator[str, Any, None]: ...  # Y058 Use "Iterator" as the return value for simple "__iter__" methods, e.g. "def __iter__(self) -> Iterator[str]: ..."

class IteratorReturningComplexGenerator:
    def __iter__(self) -> Generator[str, int, bytes]: ...

class BadAsyncIterator(collections.abc.AsyncIterator[str]):
    def __aiter__(self) -> typing.AsyncIterator[str]: ...  # Y034 "__aiter__" methods in classes like "BadAsyncIterator" usually return "self" at runtime. Consider using "typing_extensions.Self" in "BadAsyncIterator.__aiter__", e.g. "def __aiter__(self) -> Self: ..."  # Y022 Use "collections.abc.AsyncIterator[T]" instead of "typing.AsyncIterator[T]" (PEP 585 syntax)

class AsyncIteratorReturningAsyncIterable:
    def __aiter__(self) -> AsyncIterable[str]: ...  # Y045 "__aiter__" methods should return an AsyncIterator, not an AsyncIterable

class AsyncIteratorReturningSimpleAsyncGenerator1:
    def __aiter__(self) -> AsyncGenerator: ...  # Y058 Use "AsyncIterator" as the return value for simple "__aiter__" methods, e.g. "def __aiter__(self) -> AsyncIterator: ..."

class AsyncIteratorReturningSimpleAsyncGenerator2:
    def __aiter__(self) -> collections.abc.AsyncGenerator[str, Any]: ...  # Y058 Use "AsyncIterator" as the return value for simple "__aiter__" methods, e.g. "def __aiter__(self) -> AsyncIterator[str]: ..."

class AsyncIteratorReturningComplexAsyncGenerator:
    def __aiter__(self) -> AsyncGenerator[str, int]: ...

class MetaclassInWhichSelfCannotBeUsed(type):
    def __new__(cls) -> MetaclassInWhichSelfCannotBeUsed: ...
    def __enter__(self) -> MetaclassInWhichSelfCannotBeUsed: ...
    async def __aenter__(self) -> MetaclassInWhichSelfCannotBeUsed: ...
    def __isub__(self, other: MetaclassInWhichSelfCannotBeUsed) -> MetaclassInWhichSelfCannotBeUsed: ...

class MetaclassInWhichSelfCannotBeUsed2(EnumMeta):
    def __new__(cls) -> MetaclassInWhichSelfCannotBeUsed2: ...
    def __enter__(self) -> MetaclassInWhichSelfCannotBeUsed2: ...
    async def __aenter__(self) -> MetaclassInWhichSelfCannotBeUsed2: ...
    def __isub__(self, other: MetaclassInWhichSelfCannotBeUsed2) -> MetaclassInWhichSelfCannotBeUsed2: ...

class MetaclassInWhichSelfCannotBeUsed3(enum.EnumType):
    def __new__(cls) -> MetaclassInWhichSelfCannotBeUsed3: ...
    def __enter__(self) -> MetaclassInWhichSelfCannotBeUsed3: ...
    async def __aenter__(self) -> MetaclassInWhichSelfCannotBeUsed3: ...
    def __isub__(self, other: MetaclassInWhichSelfCannotBeUsed3) -> MetaclassInWhichSelfCannotBeUsed3: ...

class MetaclassInWhichSelfCannotBeUsed4(ABCMeta):
    def __new__(cls) -> MetaclassInWhichSelfCannotBeUsed4: ...
    def __enter__(self) -> MetaclassInWhichSelfCannotBeUsed4: ...
    async def __aenter__(self) -> MetaclassInWhichSelfCannotBeUsed4: ...
    def __isub__(self, other: MetaclassInWhichSelfCannotBeUsed4) -> MetaclassInWhichSelfCannotBeUsed4: ...

class Abstract(Iterator[str]):
    @abstractmethod
    def __iter__(self) -> Iterator[str]: ...
    @abstractmethod
    def __enter__(self) -> Abstract: ...
    @abstractmethod
    async def __aenter__(self) -> Abstract: ...

class GoodIterator(Iterator[str]):
    def __iter__(self: Self) -> Self: ...

class GoodAsyncIterator(AsyncIterator[int]):
    def __aiter__(self: Self) -> Self: ...

class DoesNotInheritFromIterator:
    def __iter__(self) -> DoesNotInheritFromIterator: ...

class Unannotated:
    def __new__(cls, *args, **kwargs): ...
    def __iter__(self): ...
    def __aiter__(self): ...
    async def __aenter__(self): ...
    def __repr__(self): ...
    def __str__(self): ...
    def __eq__(self): ...
    def __ne__(self): ...
    def __iadd__(self): ...
    def __ior__(self): ...

def __repr__(self) -> str: ...
def __str__(self) -> str: ...
def __eq__(self, other: Any) -> bool: ...
def __ne__(self, other: Any) -> bool: ...
def __imul__(self, other: Any) -> list[str]: ...

_S = TypeVar("_S")
_T = TypeVar("_T")

class BadGeneric(Generic[_T], int): ...  # Y059 "Generic[]" should always be the last base class
class GoodGeneric(Generic[_T]): ...

class BadGeneric2(int, typing.Generic[_T], str): ...  # Y059 "Generic[]" should always be the last base class
class GoodGeneric2(int, typing.Generic[_T]): ...

class BadGeneric3(typing_extensions.Generic[_T], int, str): ...  # Y059 "Generic[]" should always be the last base class
class GoodGeneric3(int, str, typing_extensions.Generic[_T]): ...

class BadGeneric4(Generic[_T], Iterable[int], str): ...  # Y059 "Generic[]" should always be the last base class
class GoodGeneric4(Iterable[int], str, Generic[_T]): ...

class RedundantGeneric1(Iterable[_T], Generic[_T]): ...  # Y060 Redundant inheritance from "Generic[_T]"; class would be inferred as generic anyway
class Corrected1(Iterable[_T]): ...

class RedundantGeneric2(Generic[_S], GoodGeneric[_S]): ...  # Y059 "Generic[]" should always be the last base class  # Y060 Redundant inheritance from "Generic[_S]"; class would be inferred as generic anyway
class Corrected2(GoodGeneric[_S]): ...

class RedundantGeneric3(int, Iterator[_T], str, float, memoryview, bytes, Generic[_T]): ...  # Y060 Redundant inheritance from "Generic[_T]"; class would be inferred as generic anyway
class Corrected3(int, Iterator[_T], str, float, memoryview, bytes): ...

class RedundantGeneric4(Iterable[_T], Iterator[_T], Generic[_T]): ...  # Y060 Redundant inheritance from "Generic[_T]"; class would be inferred as generic anyway
class Corrected4(Iterable[_T], Iterator[_T]): ...

class BadAndRedundantGeneric(object, Generic[_T], Container[_T]): ...  # Y040 Do not inherit from "object" explicitly, as it is redundant in Python 3  # Y059 "Generic[]" should always be the last base class  # Y060 Redundant inheritance from "Generic[_T]"; class would be inferred as generic anyway
class Corrected5(Container[_T]): ...

# Strictly speaking this inheritance from Generic is "redundant",
# but people may consider it more readable to explicitly inherit from Generic,
# so we deliberately don't flag it with Y060
class GoodGeneric5(Container[_S], Iterator[_T], Generic[_S, _T]): ...

# And these definitely arent't redundant,
# since the order of the type variables is changed via the inheritance from Generic:
class GoodGeneric6(Container[_S], Iterator[_T], Generic[_T, _S]): ...
class GoodGeneric7(Mapping[_S, _T], Generic[_T, _S]): ...
