import abc
import collections.abc
import typing
from abc import abstractmethod
from typing import Any, AsyncIterator, Iterator, overload

import typing_extensions
from _typeshed import Self
from typing_extensions import final

class Bad:
    def __new__(cls, *args: Any, **kwargs: Any) -> Bad: ...  # Y034 "__new__" methods usually return "self" at runtime. Consider using "_typeshed.Self" in "Bad.__new__", e.g. "def __new__(cls: type[Self], *args: Any, **kwargs: Any) -> Self: ..."
    def __repr__(self) -> str: ...  # Y029 Defining __repr__ or __str__ in a stub is almost always redundant
    def __str__(self) -> str: ...  # Y029 Defining __repr__ or __str__ in a stub is almost always redundant
    def __eq__(self, other: Any) -> bool: ...  # Y032 Prefer "object" to "Any" for the second parameter in "__eq__" methods
    def __ne__(self, other: typing.Any) -> typing.Any: ...  # Y032 Prefer "object" to "Any" for the second parameter in "__ne__" methods
    def __enter__(self) -> Bad: ...  # Y034 "__enter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "_typeshed.Self" in "Bad.__enter__", e.g. "def __enter__(self: Self) -> Self: ..."
    async def __aenter__(self) -> Bad: ...  # Y034 "__aenter__" methods in classes like "Bad" usually return "self" at runtime. Consider using "_typeshed.Self" in "Bad.__aenter__", e.g. "async def __aenter__(self: Self) -> Self: ..."

class Good:
    def __new__(cls: type[Self], *args: Any, **kwargs: Any) -> Self: ...
    @abstractmethod
    def __str__(self) -> str: ...
    @abc.abstractmethod
    def __repr__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, obj: object) -> int: ...
    def __enter__(self: Self) -> Self: ...
    async def __aenter__(self: Self) -> Self: ...

class Fine:
    @overload
    def __new__(cls, foo: int) -> FineSubclass: ...
    @overload
    def __new__(cls, *args: Any, **kwargs: Any) -> Fine: ...
    @abc.abstractmethod
    def __str__(self) -> str: ...
    @abc.abstractmethod
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any, strange_extra_arg: list[str]) -> Any: ...
    def __ne__(self, *, kw_only_other: Any) -> bool: ...
    def __enter__(self) -> None: ...
    def __aenter__(self) -> bool: ...

class FineSubclass(Fine): ...

class AlsoGood(str):
    def __str__(self) -> AlsoGood: ...
    def __repr__(self) -> AlsoGood: ...

class FineAndDandy:
    def __str__(self, weird_extra_arg) -> str: ...
    def __repr__(self, weird_extra_arg_with_default=...) -> str: ...

@final
class WillNotBeSubclassed:
    def __new__(cls, *args: Any, **kwargs: Any) -> WillNotBeSubclassed: ...
    def __enter__(self) -> WillNotBeSubclassed: ...
    async def __aenter__(self) -> WillNotBeSubclassed: ...

class InvalidButPluginDoesNotCrash:
    def __new__() -> InvalidButPluginDoesNotCrash: ...  # Y034 "__new__" methods usually return "self" at runtime. Consider using "_typeshed.Self" in "InvalidButPluginDoesNotCrash.__new__".
    def __enter__() -> InvalidButPluginDoesNotCrash: ...  # Y034 "__enter__" methods in classes like "InvalidButPluginDoesNotCrash" usually return "self" at runtime. Consider using "_typeshed.Self" in "InvalidButPluginDoesNotCrash.__enter__".
    async def __aenter__() -> InvalidButPluginDoesNotCrash: ...  # Y034 "__aenter__" methods in classes like "InvalidButPluginDoesNotCrash" usually return "self" at runtime. Consider using "_typeshed.Self" in "InvalidButPluginDoesNotCrash.__aenter__".

class BadIterator1(Iterator[int]):
    def __iter__(self) -> Iterator[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator1" usually return "self" at runtime. Consider using "_typeshed.Self" in "BadIterator1.__iter__", e.g. "def __iter__(self: Self) -> Self: ..."

class BadIterator2(typing.Iterator[int]):
    def __iter__(self) -> Iterator[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator2" usually return "self" at runtime. Consider using "_typeshed.Self" in "BadIterator2.__iter__", e.g. "def __iter__(self: Self) -> Self: ..."

class BadIterator3(typing_extensions.Iterator[int]):
    def __iter__(self) -> collections.abc.Iterator[int]: ...  # Y034 "__iter__" methods in classes like "BadIterator3" usually return "self" at runtime. Consider using "_typeshed.Self" in "BadIterator3.__iter__", e.g. "def __iter__(self: Self) -> Self: ..."

class BadAsyncIterator(collections.abc.AsyncIterator[str]):
    def __aiter__(self) -> typing.AsyncIterator[str]: ...  # Y034 "__aiter__" methods in classes like "BadAsyncIterator" usually return "self" at runtime. Consider using "_typeshed.Self" in "BadAsyncIterator.__aiter__", e.g. "def __aiter__(self: Self) -> Self: ..."

class Abstract(Iterator[str]):
    @abstractmethod
    def __iter__(self) -> Iterator[str]: ...
    @abstractmethod
    def __enter__(self) -> Abstract: ...
    @abstractmethod
    async def __aenter__(self) -> Abstract: ...

class GoodIterator(Iterator[str]):
    def __iter__(self: Self) -> Self: ...

class GoodAsyncIterator(AsyncIterator[int]):
    def __aiter__(self: Self) -> Self: ...

class DoesNotInheritFromIterator:
    def __iter__(self) -> DoesNotInheritFromIterator: ...

def __repr__(self) -> str: ...
def __str__(self) -> str: ...
def __eq__(self, other: Any) -> bool: ...
def __ne__(self, other: Any) -> bool: ...
